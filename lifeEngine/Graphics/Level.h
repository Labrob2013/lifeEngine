//////////////////////////////////////////////////////////////////////////
// 
//			*** lifeEngine (Двигатель Жизни) ***
//					Copyright (C) 2017
//
// Связь со мной:		https://vk.com/zombihello
// Репозиторий движка:  https://github.com/zombihello/lifeEngine
// 
//////////////////////////////////////////////////////////////////////////

#ifndef LEVEL_H
#define LEVEL_H

#define COMPILING_LIBRARY
#include <DllGlobal.h>

//////////////////
// LIFEENGINE
//////////////////
#include <System\VAO.h>
#include <Graphics\Skybox.h>
#include <Graphics\Plane.h>
#include <Graphics\Entity.h>

namespace le
{
	//-------------------------------------------------------------------------//

	class LightManager;
	class Scene;

	//-------------------------------------------------------------------------//

	//////////////////////////////////////////////////////////////////////
	/// \brief Структура заголовка BSP файла
	//////////////////////////////////////////////////////////////////////
	struct BSPHeader
	{
		char		StrID[ 4 ];		///< Это всегда должно быть 'LBSP'
		int			Version;		///< Версия формата (на данный момент версия - 0x10)
	};

	//-------------------------------------------------------------------------//

	//////////////////////////////////////////////////////////////////////
	/// \brief Структура одного куска BSP файла
	//////////////////////////////////////////////////////////////////////
	struct BSPLump
	{
		int			Offset;			///< Смещение в файле до начала этого куска
		int			Length;			///< Длина в байтах для этого куска	
	};

	//-------------------------------------------------------------------------//

	//////////////////////////////////////////////////////////////////////
	/// \brief Структура вершин BSP файла
	//////////////////////////////////////////////////////////////////////
	struct BSPVertex
	{
		glm::vec3		Position;			///< Позиция вершины
		glm::vec2		TextureCoord;		///< Текстурные координаты
		glm::vec2		LightmapCoord;		///< Координаты светокарты (lightmap)
		glm::vec3		Normal;				///< Нормаль вершины
		byte			Color[ 4 ];			///< RGBA цвет для вершин

		bool operator==( BSPVertex& Vertex );
	};

	//-------------------------------------------------------------------------//

	//////////////////////////////////////////////////////////////////////
	/// \brief Структура фейсов BSP файла
	//////////////////////////////////////////////////////////////////////
	struct BSPFace
	{
		int			TextureID;			///< Идентификатор текстуры
		int			Effect;				///< Индекс эффектов (-1 = n/a)
		int			Type;				///< Тип фейса (1 = полигон, 2 = патч, 3 = меш, 4 = билборд)
		int			StartVertIndex;		///< Начальный индекс первой вершины
		int			NumOfVerts;			///< Количество вершин
		int			StartIndex;			///< Начальный индекс в массиве индексов
		int			NumOfIndices;		///< Количество индексов в фейсе
		int			LightmapID;			///< Идентификатор карты освещения
		int			LMapCorner[ 2 ];	///< Угол света в изображении фейса
		int			LMapSize[ 2 ];		///< Размер секции световой карты
		glm::vec3	LMapPos;			///< Позиция световой карты.
		glm::vec3	LMapVecs[ 2 ];		///< 3D-пространство для S и T единичных векторов
		glm::vec3	Normal;				///< Нормаль фейса
		int			Size[ 2 ];			///< Габаритные размеры безье
	};

	//-------------------------------------------------------------------------//

	//////////////////////////////////////////////////////////////////////
	/// \brief Структура текстуры BSP файла
	//////////////////////////////////////////////////////////////////////
	struct BSPTexture
	{
		char	StrName[ 64 ];				///< Название текстуры без расширения
		int		Flags;						///< Поверхностные флаги
		int		Contents;					///< Флаги содержимого
	};

	//-------------------------------------------------------------------------//

	//////////////////////////////////////////////////////////////////////
	/// \brief Структура карт освещения BSP файла
	//////////////////////////////////////////////////////////////////////
	struct BSPLightmap
	{
		byte	ImageBits[ 128 ][ 128 ][ 3 ];		///< Данные в формате RGB разрешения 128x128
	};

	//-------------------------------------------------------------------------//

	//////////////////////////////////////////////////////////////////////
	/// \brief Класс для работы с уровнем
	//////////////////////////////////////////////////////////////////////
	class DLL_API Level
	{
	public:

		//-------------------------------------------------------------------------//

		//////////////////////////////////////////////////////////////////////
		/// \brief Перечисление типов кусков BSP файла
		//////////////////////////////////////////////////////////////////////
		enum Lumps
		{
			Entities = 0,				///< Хранит позицию игрока, объекта и т.д
			Textures,					///< Хранит информацию про текстуры
			Planes,						///< Хранит плоскости
			Nodes,						///< Хранит BSP ветки
			Leafs,						///< Хранит листы узлов
			LeafFaces,					///< Хранит индексы листа в фейсах
			LeafBrushes,				///< Хранит индексы листа в брашах
			Models,						///< Хранит информацию о моделях
			Brushes,					///< Хранит информацию о брашах (для коллизии)
			BrushSides,					///< Хранит информацию о поверхностях браша
			Vertices,					///< Хранит вершины уровня
			Indices,					///< Хранит индексы уровня
			Shaders,					///< Хранит файлы шейдеров (смешивание, анимация ..)
			Faces,						///< Хранит фейся уровня
			Lightmaps,					///< Хранит световые карты для уровня
			LightVolumes,				///< Хранит дополнительную информацию о освещении света
			VisData,					///< Хранит PVS и информацию о кластере (видимость)
			MaxLumps					///< Константа для хранения количества кусков
		};

		//-------------------------------------------------------------------------//

		//////////////////////////////////////////////////////////////////////
		/// \brief Конструктор
		//////////////////////////////////////////////////////////////////////
		Level( System& System );

		//////////////////////////////////////////////////////////////////////
		/// \brief Деструктор
		//////////////////////////////////////////////////////////////////////
		~Level();

		//////////////////////////////////////////////////////////////////////
		/// \brief Загрузить карту в формате BSP (Версия Quake 3)
		///
		/// \param[in] Route Путь к файлу
		/// \return true если все прошло успешно, иначе false
		//////////////////////////////////////////////////////////////////////
		bool LoadLevel( const string& Route );

		//////////////////////////////////////////////////////////////////////
		/// \brief Добавить на сцену
		///		
		/// \param[in] Scene Сцена
		//////////////////////////////////////////////////////////////////////
		void AddToScene( Scene& Scene );

		//////////////////////////////////////////////////////////////////////
		/// \brief Удалить с сцены
		//////////////////////////////////////////////////////////////////////
		void RemoveFromScene();

		//////////////////////////////////////////////////////////////////////
		/// \brief Указать сцену (необходима для уничтожения со сцены)
		///		
		/// \param[in] Scene Сцена
		//////////////////////////////////////////////////////////////////////
		void SetScene( Scene* Scene );

		//////////////////////////////////////////////////////////////////////
		/// \brief Очистить уровень
		//////////////////////////////////////////////////////////////////////
		void ClearLevel();

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить скайбокс уровня
		///		
		/// \return Skybox&.
		//////////////////////////////////////////////////////////////////////
		Skybox& GetSkybox();

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить VAO уровня
		///		
		/// \return Массив буфером уровня в OpenGL
		//////////////////////////////////////////////////////////////////////
		GLuint& GetArrayBuffer();

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить энтити по названию
		///		
		/// \param[in] NameEntity Название энтити
		/// \return Entity*. Если не нашли энтити,то вернет NULL
		//////////////////////////////////////////////////////////////////////
		Entity* GetEntity( const string& NameEntity );

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить все плоскости на уровне
		///		
		/// \return Массив плоскостей на уровне
		//////////////////////////////////////////////////////////////////////
		map<GLuint, vector<Plane*> >& GetAllPlanes();

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить все энтити на уровне
		///		
		/// \return vector<Entity*>&
		//////////////////////////////////////////////////////////////////////
		vector<Entity>& GetAllEntitys();

	private:

		//////////////////////////////////////////////////////////////////////
		/// \brief Изменить уровень гаммы на текстуре
		///		
		/// \param[in] ImageBits Массив байт изображения
		/// \param[in] Size Размер изображения
		/// \param[in] Factor Фактор гаммы
		//////////////////////////////////////////////////////////////////////
		void ChangeGamma( byte *ImageBits, int Size, float Factor );

		//////////////////////////////////////////////////////////////////////
		/// \brief Загрузить в OpenGL карту освещения с памяти
		///		
		/// \param[in] ImageBits Массив байт изображения
		/// \param[in] Width Длина изображения
		/// \param[in] Height Высота изображения
		//////////////////////////////////////////////////////////////////////
		void CreateLightmapTexture( byte *ImageBits, int Width, int Height );

		Scene*							Scene;				///< Сцена на котором находится уровень
		Skybox*							Skybox;				///< Скайбокс уровня

		GLuint							VertexBuffer;		///< Вершиный буфер
		GLuint							IndexBuffer;		///< Индексный буфер
		GLuint							ArrayBuffer;		///< VAO

		map<GLuint, vector<Plane*> >	ArrayPlanes;		///< Массив плоскостей уровня разделенный на текстуры
		vector<Entity>					ArrayEntitys;		///< Массив энтити-объектов
		vector<GLuint>					ArrayLightmaps;		///< Массив идентификаторов карт освещения
	};

	//-------------------------------------------------------------------------//
}

#endif //LEVEL_H

