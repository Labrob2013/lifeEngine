//////////////////////////////////////////////////////////////////////////
// 
//			*** lifeEngine (Двигатель Жизни) ***
//					Copyright (C) 2017
//
// Связь со мной:		https://vk.com/zombihello
// Репозиторий движка:  https://github.com/zombihello/lifeEngine
// 
//////////////////////////////////////////////////////////////////////////

#ifndef SCENE_H
#define SCENE_H

#define COMPILING_LIBRARY
#include <DllGlobal.h>

///////////////////////////
// СИСТЕМНЫЕ БИБЛИОТЕКИ
///////////////////////////
#include <vector>
#include <map>
using namespace std;

//////////////
// OPENGL
//////////////
#include <glew\glew.h>
#include <glm\glm.hpp>

//////////////////
// SFML
//////////////////
#include <SFML\Graphics.hpp>
#include <SFML\OpenGL.hpp>
using namespace sf;

////////////////
// LIFEENGINE
///////////////
#include <System\System.h>
#include <System\GBuffer.h>
#include <Graphics\LightQuad.h>

namespace le
{
	//-------------------------------------------------------------------------//

	class Model;
	class BoundingBox;
	class Camera;
	class Frustum;
	class Level;
	class Brush;
	struct BrushPlane;
	class Skeleton;
	class PointLight;
	class DirectionalLight;
	class SpotLight;
	class LightManager;
	class Skybox;

	//-------------------------------------------------------------------------//

	//////////////////////////////////////////////////////////////////////
	/// \brief Класс для работы со сценой
	///
	/// Данный класс необходим для рендера графики на экран
	//////////////////////////////////////////////////////////////////////
	class DLL_API Scene
	{
	public:

		//-------------------------------------------------------------------------//

		//////////////////////////////////////////////////////////////////////
		/// \brief Структура хранения меша для сцены
		//////////////////////////////////////////////////////////////////////
		struct DLL_API InfoMesh
		{
			//////////////////////////////////////////////////////////////////////
			/// \brief Конструктор
			//////////////////////////////////////////////////////////////////////
			InfoMesh();

			int					CountIndexs; ///< Количество индексов вершин
			float				DistanceToCamera; ///< Растояние между объектом и камерой
			bool				IsRender; ///< Рендерить ли этот меш

			GLuint				VertexArray; ///< VAO
			Skeleton*			Skeleton; ///< Скелет меша
			BoundingBox*		BoundingBox; ///< Ограничивающее тело меша

			glm::vec3*			Position; ///< Позиция меша на сцене
			glm::mat4*			MatrixTransformation; ///< Матрица трансформации меша
		};

		//-------------------------------------------------------------------------//

		//////////////////////////////////////////////////////////////////////
		/// \brief Конструктор
		//////////////////////////////////////////////////////////////////////
		Scene();

		//////////////////////////////////////////////////////////////////////
		/// \brief Деструктор
		//////////////////////////////////////////////////////////////////////
		~Scene();

		//////////////////////////////////////////////////////////////////////
		/// \brief Добавить модель на сцену
		///		
		/// \param[in] Model Указатель на модель
		//////////////////////////////////////////////////////////////////////
		void AddModelToScene( Model* Model );

		//////////////////////////////////////////////////////////////////////
		/// \brief Удалить модель с сцены
		///		
		/// \param[in] Model Указатель на модель
		//////////////////////////////////////////////////////////////////////
		void RemoveModelFromScene( Model* Model );

		//////////////////////////////////////////////////////////////////////
		/// \brief Добавить уровень на сцену
		///		
		/// \param[in] Level Указатель на уровень
		//////////////////////////////////////////////////////////////////////
		void AddLevelToScene( Level* Level );

		//////////////////////////////////////////////////////////////////////
		/// \brief Удалить уровень с сцены
		///		
		/// \param[in] Level Указатель на уровень
		//////////////////////////////////////////////////////////////////////
		void RemoveLevelFromScene( Level* Level );

		//////////////////////////////////////////////////////////////////////
		/// \brief Добавить менеджер света на сцену
		///		
		/// \param[in] LightManager Указатель на менеджер света
		//////////////////////////////////////////////////////////////////////
		void AddLightManagerToScene( LightManager* LightManager );

		//////////////////////////////////////////////////////////////////////
		/// \brief Удалить менеджер света со сцены
		///		
		/// \param[in] LightManager Указатель на менеджер света
		//////////////////////////////////////////////////////////////////////
		void RemoveLightManagerFromScene( LightManager* LightManager );

		//////////////////////////////////////////////////////////////////////
		/// \brief Убрать камеру со сцены
		//////////////////////////////////////////////////////////////////////
		void RemoveCamera();

		//////////////////////////////////////////////////////////////////////
		/// \brief Отрендерить сцену
		//////////////////////////////////////////////////////////////////////
		void RenderScene();

		//////////////////////////////////////////////////////////////////////
		/// \brief Очистить сцену
		//////////////////////////////////////////////////////////////////////
		void ClearScene();

		//////////////////////////////////////////////////////////////////////
		/// \brief Задать камеру
		///		
		/// \param[in] Camera Камера
		//////////////////////////////////////////////////////////////////////
		void SetCamera( Camera& Camera );

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить G-Буффер сцены
		///		
		/// \return GBuffer&
		//////////////////////////////////////////////////////////////////////
		GBuffer& GetGBuffer();

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить карту наход. на сцене
		///		
		/// \return Level*, если ее нету, то вернет NULL
		//////////////////////////////////////////////////////////////////////
		Level* GetLevel();

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить кол-во видимых точечных источников света
		/// \warning Кол-во объектов которые попали в камеру без учета перекрытий
		///		
		/// \return size_t&
		//////////////////////////////////////////////////////////////////////
		size_t& GetVisible_PointLight();

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить кол-во видимых прожекторных источников света
		/// \warning Кол-во объектов которые попали в камеру без учета перекрытий
		///		
		/// \return size_t&
		//////////////////////////////////////////////////////////////////////
		size_t& GetVisible_SpotLight();

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить кол-во видимых моделей
		/// \warning Кол-во объектов которые попали в камеру без учета перекрытий
		///		
		/// \return size_t&
		//////////////////////////////////////////////////////////////////////
		size_t& GetVisible_Models();

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить кол-во видимых брашей
		/// \warning Кол-во объектов которые попали в камеру без учета перекрытий
		///		
		/// \return size_t&
		//////////////////////////////////////////////////////////////////////
		size_t& GetVisible_Brushes();

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить буффер точечного света который попал в камеру
		///		
		/// \return vector<PointLight*>&
		//////////////////////////////////////////////////////////////////////
		vector<PointLight*>& GetLightBuffer_PointLight();

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить буффер прожекторного света который попал в камеру
		///		
		/// \return vector<SpotLight*>&
		//////////////////////////////////////////////////////////////////////
		vector<SpotLight*>& GetLightBuffer_SpotLight();

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить геометрию анимируемых моделей
		///		
		/// \return map<GLuint, vector<InfoMesh*> >&
		//////////////////////////////////////////////////////////////////////
		map<GLuint, vector<InfoMesh*> >& GetRenderBuffer_AnimationModel();

		//////////////////////////////////////////////////////////////////////
		/// \brief Получить геометрию статичных моделей
		///		
		/// \return map<GLuint, vector<InfoMesh*> >&
		//////////////////////////////////////////////////////////////////////
		map<GLuint, vector<InfoMesh*> >& GetRenderBuffer_StaticModel();

	private:
		//////////////////////////////////////////////////////////////////////
		/// \brief Отсечь невидимые объекты по пирамиде видимости
		//////////////////////////////////////////////////////////////////////
		void FrustumCulling();

		//////////////////////////////////////////////////////////////////////
		/// \brief Построить карты теней
		//////////////////////////////////////////////////////////////////////
		void BuildShadowMaps();

		//////////////////////////////////////////////////////////////////////
		/// \brief Отрендерить геометрию сцены
		//////////////////////////////////////////////////////////////////////
		void GeometryRender();

		//////////////////////////////////////////////////////////////////////
		/// \brief Отрендерить освещение сцены
		//////////////////////////////////////////////////////////////////////
		void LightRender();

		//////////////////////////////////////////////////////////////////////
		/// \brief Отрендерить точечные источники света
		///
		/// \param[in] Index Индекс элемента в массиве
		//////////////////////////////////////////////////////////////////////
		void RenderPointLight( const size_t& Index );

		//////////////////////////////////////////////////////////////////////
		/// \brief Отрендерить прожекторные источники света
		///
		/// \param[in] Index Индекс элемента в массиве
		//////////////////////////////////////////////////////////////////////
		void RenderSpotLight( const size_t& Index );

		//////////////////////////////////////////////////////////////////////
		/// \brief Отрендерить направленый источник света
		///
		/// \param[in] Index Индекс элемента в массиве
		//////////////////////////////////////////////////////////////////////
		void RenderDirectionalLight( const size_t& Index );

		Shader*								AnimationModelsRender; ///< Шейдер рендера анимируемых моделей
		Shader*								StaticModelsRender; ///< Шейдер рендера статичных моделей
		Shader*								LevelRender; ///< Шейдер рендера уровня
		Shader*								TestRender; ///< Шейдер тестового рендера на перекрытия
		Shader*								LightMapRender; ///< Шейдер рендера карт освещения
		Shader*								PointLightRender; ///< Шейдер точечного света
		Shader*								DirectionalLightRender; ///< Шейдер направленого света
		Shader*								SpotLightRender; ///< Шейдер прожекторного света
		
		size_t								Visible_PointLight; ///< Кол-во видимых точечных источников света
		size_t								Visible_SpotLight; ///< Кол-во видимых прожекторных источников света
		size_t								Visible_Models; ///< Кол-во видимых моделей
		size_t								Visible_Brushes; ///< Кол-во видимых брашей

		glm::vec3*							PositionCamera; ///< Позиция камеры
		glm::mat4*							ViewMatrix; ///< Матрица вида
		glm::mat4*							ProjectionMatrix; ///< Матрица проекции
		glm::mat4							PVMatrix; ///< Матрица Projection * View
		glm::mat4							PVTMatrix; ///< Матрица Projection * View * Transformation

		Frustum*							Frustum; ///< Пирамида усечения
		Camera*								Camera; ///< Камера
		Level*								LevelInScene; ///< Уровень который нах. на сцене
		LightManager*						LightManager; ///< Менеджер света который прикреплен к сцене
		Skybox*								Skybox; ///< Скайбокс сцены
		GBuffer								GBuffer; ///< G-Буффер
		LightQuad							LightQuad; ///< Квадрат для рендера направленого и прожекторного света
		InfoMesh*							Ptr_InfoMesh; ///< Вспомогательный указатель на класс InfoMesh
		vector<InfoMesh*>*					Ptr_GeometryBuffer; ///< Вспомогательный указатель на массив InfoMesh'ей

		vector<Model*>						ModelsInScene; ///< Массив моделей которые нах. на сцене
		vector<PointLight>*					PointLights; ///< Массив точечный источников которые нах. на сцене
		vector<SpotLight>*					SpotLights; ///< Массив прожекторных источников которые нах. на сцене
		vector<DirectionalLight>*			DirectionalLights; ///< Массив направленных источников света которые нах. на сцене
		vector<Brush*>						GeometryBuffer_Level; ///< Буффер геометрии уровня (отсортированый по удалению от камеры)
		vector<InfoMesh*>					GeometryBuffer_Models; ///< Буффер геометрии моделей
		vector<PointLight*>					LightBuffer_PointLight; ///< Буффер точечного света который попал в камеру
		vector<SpotLight*>					LightBuffer_SpotLight; ///< Буффер прожекторного света который попал в камеру

		map<GLuint, vector<BrushPlane*> >	RenderBuffer_Level; ///< Буффер рендера карты
		map<GLuint, vector<InfoMesh*> >		RenderBuffer_AnimationModel; ///< Буффер рендера анимируемых моделей
		map<GLuint, vector<InfoMesh*> >		RenderBuffer_StaticModel; ///< Буффер рендера статичных моделей (не анимируемых)	
	};

	//-------------------------------------------------------------------------//
}

#endif // SCENE_H
